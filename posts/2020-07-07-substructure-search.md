---
layout: post
title: Implementing and Optimizing Chemical Substructure Search Using MongoDB
---
<div class="message">
  This post is long and relatively technical.
</div>
## Background
Small molecule drug development often relies on establishing a group of **lead compounds**, previously known chemicals whose structures exhibit therapeutic potential. The idea is that once said potential is combined with a series of pharmacological improvements, the company will be able to easily manufacture and market the drug.

To identify lead compounds, scientists start with a lead template that specifies desirable structural components. They then conduct a search across thousands—sometimes millions—of known molecules. This search can take the form of high-throughput screening (a series of small physical experiments), physically discovering naturally-produced products (ex. snorkeling for bacteria in the Bahamas), or employing software to search chemical databases.

The software search is what we're interested in here. Our approach will be to look for molecules that have exactly the structural components that we want. For instance, suppose that the drug mechanism relies on the structural component below, written in SMILES format as `"ccO"`:
<div style="display: flex; flex-direction: row; justify-content: center;">
<img src="/assets/ccO.png"
     alt="Two carbons and an oxygen"
     style="width: 30%;" />
</div>

A "hit" in this case would be phenol, which contains `"ccO"` as an exact substructure:
<div style="display: flex; flex-direction: column; justify-content: center; margin-bottom: 1rem; margin-top: -2rem">
<img src="/assets/c1ccccc1O.png"
     alt="phenol"
     style="width: 30%; margin: auto; display: inline;" />

<img src="/assets/ccOsubstruct.png"
     alt="phenol with highlighted substructure"
     style="width: 30%; margin: auto; display: inline;" />
</div>
## Naive Algorithm
We now have the entire problem statement: given a large database of molecules and a desirable pattern, find and return all molecules that have the pattern as an exact substructure. Armed with RDKit, a software package that provides methods to check each molecule in the database, we can easily come up with a naive approach provided a good MongoDB database:

```python
import rdkit
import rdkit.Chem
import pymongo


# Sample document representation of a molecule
molDoc = {
  'rdmol': # Binary representation of a molecule
  'smiles': # Canonical SMILES
}


def SubSearchNaive(pattern, db):
    """
    Given a MongoDB database DB with a collection called molecules,
    return a list of all molecules that contain PATTERN
    as a substructure.
    """
    results = []
    for molDoc in db.molecules.find():
        rdmol = Chem.Mol(molDoc['rdmol'])
        if rdmol.HasSubstructMatch(pattern):
            results.append([molDoc['smiles']])
    return results
```
How performant is this approach? Since molecules are generally represented as graphs, the substructure check for each molecule is an instance of the subgraph isomorphism problem. Unfortunately, this problem is NP-complete. While the molecule graphs we're talking about won't usually exhibit worst-case time, benchmarks by Daylight Chemical Information Systems find that they still run on the order of $O(N^2)$ or $O(N^3)$. This would be incredibly time intensive for larger or more connected molecules, making this method slow for identifying lead compounds.

Luckily, NP-completeness doesn't restrict how quickly we can check a solution for correctness. In fact, we can determine that a molecule probably does not contain the pattern much more quickly than vice versa. And if we can screen out non-matching molecules before beginning to check `HasSubstructMatch` on those remaining, we can avoid a large number of expensive calls.

## Fingerprint Screening
One way to do this screening is using molecular fingerprints. Fingerprints are fixed-length bit vectors (imagine it as an array of 1s and 0s), usually 1000-4000 bits long. They are generated by taking features of a molecule (its atoms, bond pairs, bond order, etc.), hashing those features into numbers, and adding the numbers as sets of bits to a bit vector via OR operations.

The same features will generate the same set of bits, but there can be significant overlap in which patterns the bits are part of. Here's a extremely simplified example to convey the idea:
```python
molecule = "C=O"
eight_bit_fp = [0, 0, 0, 0, 0, 0, 0, 0]

a = convertToBits("C")
>>> [1, 0, 1, 1, 0, 0, 0, 0]

b = convertToBits("O")
>>> [0, 0, 1, 0, 1, 0, 0, 0]

addToFingerprint(eight_bit_fp, [a, b])
>>> [1, 0, 1, 1, 1, 0, 0, 0]
```
This makes the fingerprint much better for determining if a feature is *not* present in a molecule than determining if a feature is present. Luckily, the former is exactly what we need. Indeed, if a pattern exists as a substructure in a molecule, then every bit that pattern turns on will be turned on (usually represented by a 1) in the molecule's fingerprint.

Now we can dramatically improve our performance. First, we pre-calculate a fingerprint for each molecule, storing its bit vector and a count of how many ON bits it has in the database:
```python
def AddPatternFingerprints(db, length=1024):
    """
    Add pattern fingerprints optimized for substructure searching
    of length LENGTH to each molecule-representing
    document in database DB's molecule collection
    """
    for moldoc in db.molecules.find():
        mol = Chem.Mol(moldoc['rdmol'])
        bit_vector = list(PatternFingerprint(mol).GetOnBits())
        count = len(bit_vector)
        db.molecules.update_one({'_id': moldoc['_id']},
        {'$set': {'pattern_fp':
                    {'bits': bit_vector, 'count': count}}})
    return
```
Next, we can filter out molecules in two ways, replacing many of our calls to `HasSubstructMatch` at runtime with simple boolean comparisons:
1. Any molecule that matches must have at least as many ON bits in its fingerprint as the query pattern's fingerprint.
2. The fingerprint of any molecule that matches will have every ON bit in the query pattern's fingerprint also ON.

```python
from rdkit.Chem import AllChem

def SubSearch(pattern, db, chirality=False):
    """
    Search for all molecules in database DB that have the
    RDKit molecule PATTERN as a substructure, possibly taking
    into account CHIRALITY. Filter by fingerprint before referring
    to the subgraph isomorphism library. Returns a list of
    SMILES that matched the query.
    """
    results = []
    query_fp = list(PatternFingerprint(pattern).GetOnBits())
    qfp_len = len(query_fp)
    for molDoc in db.molecules.find(
            {'pattern_fp.count': {'$gte': qfp_len},
             'pattern_fp.bits': {'$all': query_fp}
                }):
        rdmol = Chem.Mol(molDoc['rdmol'])
        if rdmol.HasSubstructMatch(pattern, useChirality=chirality):
            results.append(molDoc['smiles'])
    return results
```
## Taking Advantage of MongoDB
...more to come...
