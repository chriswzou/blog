---
layout: post
title: Implementing and Optimizing Chemical Substructure Search Using MongoDB
---
## Background
Small molecule drug development often relies on establishing a group of **lead compounds**, previously known chemicals whose structures exhibit therapeutic potential. The idea is that once said potential is combined with a series of pharmacological improvements, the company will be able to easily manufacture and market the drug.

To identify lead compounds, scientists start with a lead template that specifies desirable structural components. They then conduct a search across thousands—sometimes millions—of known molecules. This search can take the form of high-throughput screening (a series of small physical experiments), physically discovering naturally-produced products (ex. snorkeling for bacteria in the Bahamas), or employing software to search chemical databases.

The software search is what we're interested in here. Our approach will be to look for molecules that have exactly the structural components that we want. For instance, suppose that the drug mechanism relies on the structural component below, written in SMILES format as `"ccO"`:
<div style="display: flex; flex-direction: row; justify-content: center;">
<img src="/assets/ccO.png"
     alt="Two carbons and an oxygen"
     style="width: 30%;" />
</div>

A "hit" in this case would be phenol, which contains `"ccO"` as an exact substructure:
<div style="display: flex; flex-direction: column; justify-content: center; margin-bottom: 1rem; margin-top: -2rem">
<img src="/assets/c1ccccc1O.png"
     alt="phenol"
     style="width: 30%; margin: auto; display: inline;" />

<img src="/assets/ccOsubstruct.png"
     alt="phenol with highlighted substructure"
     style="width: 30%; margin: auto; display: inline;" />
</div>
## Naive Algorithm
We now have the entire problem statement: given a large database of molecules and a desirable pattern, find and return all molecules that have the pattern as an exact substructure. Armed with RDKit, a software package that provides methods to check each molecule in the database, we can easily come up with a naive approach provided a good MongoDB database:

```python
import rdkit
import rdkit.Chem
import pymongo


# Sample document representation of a molecule
molDoc = {
  'rdmol': # Binary representation of a molecule
  'smiles': # Canonical SMILES
}


def SubSearchNaive(pattern, mol_collection, chirality=False):
    """
    Search MOL_COLLECTION for molecules with PATTERN
    as a substructure.
    """
    results = []
    for molDoc in mol_collection.find():
        rdmol = Chem.Mol(molDoc['rdmol'])
        if rdmol.HasSubstructMatch(pattern, useChirality=chirality):
            results.append(molDoc['smiles'])
    return results
```
How performant is this approach? Since molecules are generally represented as graphs, the substructure check for each molecule is an instance of the subgraph isomorphism problem. Unfortunately, this problem is NP-complete. While the molecule graphs we're talking about won't usually exhibit worst-case time, benchmarks by Daylight Chemical Information Systems find that they still run on the order of $O(N^2)$ or $O(N^3)$.

This is incredibly time consuming. For instance, the median query time on my MacBook Pro against a dataset of 100,000 molecules is around 16 seconds. When we consider that most chemical datasets number millions of molecules and that scientists will want to screen hundreds of molecules at a time, it is clear that we need to make some improvements.

Luckily, NP-completeness doesn't restrict how quickly we can check a candidate solution for *probable* incorrectness. In fact, we can determine that a molecule probably does not contain the pattern much more quickly than vice versa. If we can accurately screen out non-matching molecules before beginning to check `HasSubstructMatch` on those remaining, we can avoid a large number of expensive calls.

## Fingerprint Screening
One well-known way to do this screening is using molecular fingerprints.  Fingerprints are fixed-length bit vectors (imagine it as an array of 1s and 0s), usually 1000-4000 bits long. They are generated by taking features of a molecule (its atoms, bond pairs, bond order, etc.), hashing those features into numbers, and adding the numbers as sets of bits to a bit vector via OR operations.

The same features will generate the same set of bits, but there can be significant overlap in which patterns the bits are part of. Here's an extremely simplified example to convey the idea:
```python
molecule = "C=O"
eight_bit_fp = [0, 0, 0, 0, 0, 0, 0, 0]

a = convertToBits("C")
>>> [1, 0, 1, 1, 0, 0, 0, 0]

b = convertToBits("O")
>>> [0, 0, 1, 0, 1, 0, 0, 0]

addToFingerprint(eight_bit_fp, [a, b])
>>> [1, 0, 1, 1, 1, 0, 0, 0]
```
This makes the fingerprint much better for determining if a feature is *not* present in a molecule than determining if a feature is present. Luckily, the former is exactly what we need. Indeed, if a pattern exists as a substructure in a molecule, then every bit that pattern turns on will be turned on (usually represented by a 1) in the molecule's fingerprint.

Now we can dramatically improve our performance, drawing specifically on the way this algorithm is implemented in RDKit's PostgreSQL Chemical Cartridge. First, we pre-calculate a fingerprint for each molecule, storing its bit vector and a count of how many ON bits it has in the database:
```python
def AddPatternFingerprints(mol_collection):
    """
    Add pattern fingerprints to each document in MOL_COLLECTION.
    :param mol_collection: A MongoDB collection.
    """
    for mol_doc in mol_collection.find():
        mol = Chem.Mol(mol_doc['rdmol'])
        bit_vector = list(PatternFingerprint(mol).GetOnBits())
        bit_counts = len(bit_vector)
        mol_collection.update_one({'_id': mol_doc['_id']}, {'$set': {'pattern_fingerprint': {'bits': bit_vector, 'count': bit_counts}}})
    return
```
Next, we can filter out molecules in two ways, replacing many of our calls to `HasSubstructMatch` at runtime with boolean comparisons:
1. Any molecule that matches must have at least as many ON bits in its fingerprint as the query pattern's fingerprint.
2. The fingerprint of any molecule that matches will have every ON bit in the query pattern's fingerprint also ON.

```python
def SubSearch(pattern, mol_collection, chirality=False):
    """
    Search MOL_COLLECTION for molecules with PATTERN
    as a substructure.
    :param pattern: An rdmol object that represents a desired substructure pattern.
    :param mol_collection: A MongoDB collection.
    :param chirality: Whether or not to include stereochemistry in search. Defaults to False.
    :return: A list of SMILES that have the desired substructure pattern.
    """
    results = []
    query_fingerprint = list(PatternFingerprint(pattern).GetOnBits())
    qfp_len = len(query_fingerprint)
    for mol_doc in mol_collection.find({'pattern_fp.count': {'$gte': qfp_len},
                                     'pattern_fp.bits': {'$all': query_fingerprint}
                                     }):
        rdmol = Chem.Mol(mol_doc['rdmol'])
        if rdmol.HasSubstructMatch(pattern, useChirality=chirality):
            results.append(mol_doc['smiles'])
    return results
```
With this approach, we reduce the median query time to 60 milliseconds. This is already below the [classical UI requirement](https://www.nngroup.com/articles/response-times-3-important-limits/) of 100ms for instantaneous response, so it'd serve well for a scientist testing patterns one by one. However, we're also interested in serving scientists screening many fragments at a time, and a 500 fragment screen would still take 30 seconds. Can we make this even faster?

## Taking Advantage of MongoDB
...more to come...
